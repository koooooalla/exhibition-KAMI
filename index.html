<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>The Emotional Weather Report</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+KR:wght@400;500&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --current-bg-color: 255, 255, 255; /* White Background (RGB) */
    }
    body {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
      font-weight: 400;
      background-color: white;
      overflow: hidden; /* Prevent scrolling from chaotic content */
    }
    #report-container {
      width: 100%;
      height: calc(100vh - 120px);
      position: relative;
      overflow: hidden;
    }
    
    @media (max-width: 640px) {
      #report-container {
        height: calc(100vh - 160px);
      }
    }

    /* Common style for elements: absolutely positioned to their final spot */
    .report-element,
    .color-circle {
      position: absolute;
      opacity: 1;
      pointer-events: none;
      transform: translateY(-100vh);
      animation: fallToPlace 5s linear forwards;
      z-index: 10;
    }

    /* Text Specific Styles */
    .report-element {
      color: black;
      font-weight: normal;
      font-size: 1.75rem;
      line-height: 1.2;
      max-width: 30%;
      padding: 8px 6px;
      border-radius: 4px;
    }

    /* Color Circle Specific Styles */
    .color-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      opacity: 0.8;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      z-index: 5; /* Behind text */
    }

    /* Falling motion */
    @keyframes fallToPlace {
      0% {
        transform: translateY(-100vh);
        opacity: 0.5;
      }
      100% {
        transform: translateY(0vh) rotate(var(--element-rotation));
        opacity: 1;
      }
    }

    /* Color input */
    #mood-color-picker {
      appearance: none;
      -moz-appearance: none;
      -webkit-appearance: none;
      border: 2px solid #d1d5db;
      padding: 0;
      width: 32px;
      height: 32px;
      cursor: pointer;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    #mood-color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    #mood-color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 50%;
    }
    #mood-color-picker:hover {
      border-color: #9ca3af;
    }

    input::placeholder {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
    }
    input,
    button {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
      font-weight: 400;
    }

    /* Emotion Modal Styles */
    #emotion-modal-btn {
      cursor: pointer;
    }
    
    #emotion-modal {
      backdrop-filter: blur(4px);
    }
    
    .emotion-option {
      padding: 12px 16px;
      margin: 2px 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 8px;
      font-size: 0.875rem;
    }
    
    .emotion-option:hover {
      background-color: #f3f4f6;
      transform: translateX(4px);
    }
    
    .emotion-option.selected {
      background-color: #4f46e5;
      color: white;
      transform: translateX(4px);
    }
    
    .emotion-option.selected:hover {
      background-color: #3730a3;
    }
    
    /* Modal animation */
    #emotion-modal:not(.hidden) {
      animation: modalFadeIn 0.2s ease-out;
    }
    
    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Color Intensity Slider Styles */
    :root {
      --slider-thumb-color: #4f46e5;
      --slider-bg-gradient: linear-gradient(to right, #f3f4f6, #374151);
    }
    
    #color-intensity-slider {
      background: var(--slider-bg-gradient);
      border-radius: 4px;
    }
    
    #color-intensity-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--slider-thumb-color);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.2s ease;
    }
    
    #color-intensity-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--slider-thumb-color);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.2s ease;
    }
  </style>
</head>
<body>
  <!-- Main Display Area -->
  <div id="report-container" class="relative">
    <div
      id="loading-overlay"
      class="absolute inset-0 flex items-center justify-center bg-white/80 z-20 transition-opacity duration-500"
    >
      <div
        class="text-gray-800 text-xl font-semibold p-4 rounded-lg bg-indigo-200 shadow-xl"
      >
        Loading Emotional Archive...
      </div>
    </div>
    <!-- Elements will be injected here -->
  </div>

  <!-- Input Form (Fixed to Bottom) -->
  <div
    class="fixed bottom-0 left-0 right-0 p-4 bg-gray-100 border-t border-gray-300 shadow-2xl z-50"
    style="min-height: 180px;"
  >
    <p id="user-info" class="text-xs text-gray-500 mb-2"></p>
    <form id="submission-form" class="space-y-3">
      <!-- Text Input -->
      <div class="flex gap-3">
        <input
          type="text"
          id="feeling-text"
          placeholder="What are you feeling right now?"
          maxlength="300"
          class="flex-grow p-3 rounded-xl bg-white border border-gray-300 text-gray-800 placeholder-gray-500 focus:ring-indigo-500 focus:border-indigo-500"
          required
        />
        <button
          type="submit"
          id="submit-button"
          class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg disabled:opacity-50 flex-shrink-0"
        >
          Send
        </button>
      </div>

      <!-- Emotion Selection -->
      <div class="flex flex-col gap-2">
        <span class="text-xs text-gray-600">Select emotion:</span>
        <button 
          type="button" 
          id="emotion-modal-btn" 
          class="w-full p-3 text-left bg-white border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500 flex justify-between items-center hover:border-gray-400 transition-colors"
        >
          <span id="selected-emotion-text" class="text-gray-500">Choose an emotion...</span>
          <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
      </div>

      <!-- Emotion Modal -->
      <div 
        id="emotion-modal" 
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden"
      >
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 max-h-[80vh] overflow-hidden">
          <div class="p-4 border-b border-gray-200 flex justify-between items-center">
            <h3 class="text-lg font-semibold text-gray-800">Choose your emotion</h3>
            <button 
              type="button" 
              id="emotion-modal-close" 
              class="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
              </svg>
            </button>
          </div>
          <div class="max-h-96 overflow-y-auto p-2">
            <div class="emotion-option" data-emotion="joy" data-color="#FFD700">Joy (기쁨)</div>
            <div class="emotion-option" data-emotion="happiness" data-color="#FFF176">Happiness (행복)</div>
            <div class="emotion-option" data-emotion="excitement" data-color="#FF4500">Excitement (흥분)</div>
            <div class="emotion-option" data-emotion="love" data-color="#FF69B4">Love / Affection (사랑)</div>
            <div class="emotion-option" data-emotion="passion" data-color="#C21807">Passion (열정)</div>
            <div class="emotion-option" data-emotion="anger" data-color="#B22222">Anger (분노)</div>
            <div class="emotion-option" data-emotion="frustration" data-color="#FF8C00">Frustration (좌절)</div>
            <div class="emotion-option" data-emotion="fear" data-color="#4B0082">Fear (두려움)</div>
            <div class="emotion-option" data-emotion="anxiety" data-color="#556B2F">Anxiety (불안)</div>
            <div class="emotion-option" data-emotion="sadness" data-color="#1E3A8A">Sadness (슬픔)</div>
            <div class="emotion-option" data-emotion="disappointment" data-color="#5A6A7F">Disappointment (실망)</div>
            <div class="emotion-option" data-emotion="loneliness" data-color="#6A5ACD">Loneliness (외로움)</div>
            <div class="emotion-option" data-emotion="calm" data-color="#87CEEB">Calm / Serenity (평온)</div>
            <div class="emotion-option" data-emotion="contentment" data-color="#66CDAA">Contentment (만족)</div>
            <div class="emotion-option" data-emotion="relief" data-color="#98FB98">Relief (안도)</div>
            <div class="emotion-option" data-emotion="surprise" data-color="#FFD700">Surprise (놀람)</div>
            <div class="emotion-option" data-emotion="curiosity" data-color="#ADFF2F">Curiosity (호기심)</div>
            <div class="emotion-option" data-emotion="disgust" data-color="#556B2F">Disgust (혐오)</div>
            <div class="emotion-option" data-emotion="boredom" data-color="#A9A9A9">Boredom (지루함)</div>
            <div class="emotion-option" data-emotion="peace" data-color="#E0FFFF">Peace / Acceptance (평화)</div>
          </div>
        </div>
      </div>

      <!-- Color Intensity Control -->
      <div class="flex flex-col gap-3" id="color-intensity-section" style="display: none;">
        <div class="flex items-center gap-3">
          <span class="text-xs text-gray-600 flex-shrink-0">Selected color:</span>
          <div id="selected-color-preview" class="w-8 h-8 rounded-full border-2 border-gray-300 bg-gray-100"></div>
          <span id="selected-emotion-name" class="text-sm font-medium text-gray-700"></span>
        </div>
        
        <div class="flex flex-col gap-2">
          <span class="text-xs text-gray-600">Adjust color intensity:</span>
          <div class="flex items-center gap-3">
            <span class="text-xs text-gray-500">Light</span>
            <input 
              type="range" 
              id="color-intensity-slider" 
              min="1" 
              max="100" 
              step="1" 
              value="100"
              class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
            <span class="text-xs text-gray-500">Dark</span>
          </div>
          <div class="text-center">
            <span id="intensity-value" class="text-xs text-gray-600">100%</span>
          </div>
        </div>
      </div>

      <!-- Hidden color input for form submission -->
      <input type="hidden" id="final-color" value="#6366f1" />
    </form>
    <p id="message-status" class="text-xs mt-2 text-center text-red-600"></p>
  </div>

  <!-- Google Sheets Only Integration -->
  <script>
    /***************
     * CONFIG/STATE
     ***************/
    const APP_ID = "emoweather-sheets";
    
    // Google Apps Script 웹 앱 URL - 구글 시트 연동용
    const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwQe2HPaST9Wtm5dWwFEYYlMeJ8CzHeZzAYzuWZ5mgFl9Uwvgl9jz9cYaCCCvAdBMWP4A/exec";

    // UI Elements
    const container = document.getElementById('report-container');
    const form = document.getElementById('submission-form');
    const status = document.getElementById('message-status');
    const userInfo = document.getElementById('user-info');
    const loadingOverlay = document.getElementById('loading-overlay');
    const body = document.body;

    // Layout constants
    const FIXED_X_SLOTS = [0, 17.5, 35, 52.5, 70]; // 5 lanes
    const MAX_ELEMENT_WIDTH_PERCENT = 30;
    const ELEMENT_VISUAL_HEIGHT_PERCENT = 9;
    const START_Y_PERCENT = 88; // 입력칸 바로 위
    const HORIZONTAL_JITTER_PERCENT = 5;
    const DOT_MAX_OFFSET_X = 15;
    const DOT_MAX_OFFSET_Y = 5;

    // State management
    let currentSubmissions = [];
    const renderedElementIds = new Set();
    let lastColor = '#FFFFFF';
    let userId = generateUserId();
    let lastUpdateTime = 0;
    let pollingInterval;
    let isConnected = false;
    let selectedEmotion = null;

    /******************
     * HELPER FUNCTIONS
     ******************/
    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return [r, g, b];
    }

    function generateUserId() {
      const stored = localStorage.getItem('emoweather_user_id');
      if (stored) return stored;
      
      const newId = 'user_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('emoweather_user_id', newId);
      return newId;
    }

    function uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    }

    function ensureInitialBackground() {
      const cssVar = getComputedStyle(document.documentElement)
        .getPropertyValue('--current-bg-color')
        .trim();
      const match = cssVar.match(/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)$/);
      const [r, g, b] = match ? match.slice(1).map(n => parseInt(n, 10)) : [255, 255, 255];
      body.style.setProperty('--current-bg-color', `${r}, ${g}, ${b}`);
      body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    }

    // HSL 색상 조정 함수
    function hexToHsl(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l;

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return [h * 360, s * 100, l * 100];
    }

    function hslToHex(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;

      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };

      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }



    /**********************
     * STACKING CALCULATION
     **********************/
    function calculateNextLandingPosition(existingData) {
      // 완전 랜덤 X 위치 (더 자연스러운 분포)
      const randomX = Math.random() * (100 - MAX_ELEMENT_WIDTH_PERCENT);
      
      let groundLevel = START_Y_PERCENT;

      // 닷 위치 기준으로 충돌 검사
      existingData.forEach((data) => {
        if (data.xPos !== undefined && data.yPos !== undefined) {
          // 기존 닷의 실제 위치 계산
          const existingDotX = data.xPos + (data.dotOffsetX || 0);
          const existingDotY = data.yPos + (data.dotOffsetY || 0);
          
          // 새 닷 위치 (임시)
          const newDotOffsetX = Math.random() * DOT_MAX_OFFSET_X - DOT_MAX_OFFSET_X / 2;
          const newDotX = randomX + newDotOffsetX;
          
          // 닷끼리 거리 계산 (가까우면 위에 쌓기)
          const distance = Math.abs(newDotX - existingDotX);
          if (distance < 15) { // 15% 이내면 근처로 간주 (범위 확대)
            groundLevel = Math.min(groundLevel, existingDotY - 6); // 닷 위에 더 높이 쌓기
          }
        }
      });

      let newYPos = groundLevel;
      let newXPos = randomX;

      // 최소 높이 제한
      if (newYPos < 10) {
        newYPos = 10 + Math.random() * 5;
      }

      return { 
        xPos: newXPos, 
        yPos: newYPos,
        // 미리 닷 오프셋 계산해서 반환
        dotOffsetX: Math.random() * DOT_MAX_OFFSET_X - DOT_MAX_OFFSET_X / 2,
        dotOffsetY: Math.random() * DOT_MAX_OFFSET_Y - DOT_MAX_OFFSET_Y / 2
      };
    }

    /*******************
     * RENDERING
     *******************/
    function renderIncremental(submissions) {
      submissions.forEach((data) => {
        if (!data || renderedElementIds.has(data.id)) return;
        if (!data.text || !data.color || data.xPos === undefined || data.yPos === undefined || data.rotation === undefined) return;

        // TEXT ELEMENT
        const el = document.createElement('span');
        el.className = 'report-element';
        el.textContent = data.text;
        el.style.left = `${data.xPos}%`;
        el.style.top = `${data.yPos}%`;
        el.style.setProperty('--element-rotation', `${data.rotation}deg`);
        container.appendChild(el);

        // COLOR DOT
        const circle = document.createElement('div');
        circle.className = 'color-circle';
        circle.style.backgroundColor = data.color;
        circle.style.left = `${(data.xPos + (data.dotOffsetX || 0))}%`;
        circle.style.top = `${(data.yPos + (data.dotOffsetY || 0))}%`;
        circle.style.setProperty('--element-rotation', `${data.rotation}deg`);
        container.appendChild(circle);

        renderedElementIds.add(data.id);
        lastColor = data.color;
      });

      // 배경색 고정 (변경하지 않음)
    }

    /*******************
     * GOOGLE SHEETS INTEGRATION
     *******************/
    
    // 데이터 저장 함수 (JSONP 방식)
    async function saveToGoogleSheets(data) {
      try {
        // JSONP 방식으로 데이터 전송
        const params = new URLSearchParams({
          action: 'addSubmission',
          id: data.id,
          timestamp: new Date(data.timestamp).toISOString(),
          userId: data.userId,
          text: data.text,
          color: data.color,
          xPos: data.xPos.toString(),
          yPos: data.yPos.toString(),
          rotation: data.rotation.toString(),
          dotOffsetX: data.dotOffsetX.toString(),
          dotOffsetY: data.dotOffsetY.toString()
        });

        const response = await fetch(GOOGLE_SCRIPT_URL + '?' + params.toString(), {
          method: 'GET',
          mode: 'cors'
        });

        if (!response.ok) {
          throw new Error('Google Sheets 저장 실패');
        }

        const result = await response.json();
        return result;
      } catch (error) {
        throw error;
      }
    }

    // 데이터 읽기 함수 (실시간 공유용)
    async function loadFromGoogleSheets() {
      try {
        const response = await fetch(GOOGLE_SCRIPT_URL + '?action=getSubmissions&since=' + lastUpdateTime, {
          method: 'GET',
          mode: 'cors'
        });

        if (!response.ok) {
          throw new Error('Google Sheets 읽기 실패');
        }

        const result = await response.json();
        
        if (result.success && result.data) {
          const newSubmissions = result.data.filter(item => 
            item.timestamp > lastUpdateTime && !renderedElementIds.has(item.id)
          );

          if (newSubmissions.length > 0) {
            // 시간순 정렬
            newSubmissions.sort((a, b) => a.timestamp - b.timestamp);
            
            // 새로운 데이터만 렌더링
            renderIncremental(newSubmissions);
            
            // 전체 데이터 업데이트
            currentSubmissions = [...currentSubmissions, ...newSubmissions];
            currentSubmissions.sort((a, b) => a.timestamp - b.timestamp);
            
            // 마지막 업데이트 시간 갱신
            lastUpdateTime = Math.max(...newSubmissions.map(item => item.timestamp));
          }
        }

        if (!isConnected) {
          isConnected = true;
          updateConnectionStatus();
        }

      } catch (error) {
        if (isConnected) {
          isConnected = false;
          updateConnectionStatus();
        }
      }
    }

    // 연결 상태 업데이트
    function updateConnectionStatus() {
      // 연결 상태 표시 제거
    }

    // 주기적 폴링 시작
    function startPolling() {
      // 초기 데이터 로드
      loadFromGoogleSheets();
      
      // 3초마다 새 데이터 확인 (더 빠른 실시간 업데이트)
      pollingInterval = setInterval(() => {
        loadFromGoogleSheets();
      }, 3000);
    }

    /*******************
     * COLOR PALETTE GENERATION
     *******************/
    
    // 컬러 강도 조절 함수 (투명도 기반)
    function adjustColorIntensity(baseColor, intensityPercent) {
      // intensityPercent: 1 (매우 투명) ~ 100 (완전 불투명)
      if (!baseColor) return baseColor;
      
      const opacity = intensityPercent / 100; // 0.01 ~ 1.0으로 변환
      
      // 메인 컬러는 그대로 유지하고 투명도만 조절
      const [r, g, b] = hexToRgb(baseColor);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    
    function rgbToHex(r, g, b) {
      const toHex = (c) => {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /*******************
     * EMOTION & COLOR SELECTION
     *******************/
    function initializeEmotionSelection() {
      const modalBtn = document.getElementById('emotion-modal-btn');
      const modal = document.getElementById('emotion-modal');
      const modalClose = document.getElementById('emotion-modal-close');
      const selectedEmotionText = document.getElementById('selected-emotion-text');
      const emotionOptions = document.querySelectorAll('.emotion-option');
      const colorIntensitySection = document.getElementById('color-intensity-section');
      const selectedColorPreview = document.getElementById('selected-color-preview');
      const selectedEmotionName = document.getElementById('selected-emotion-name');
      const intensitySlider = document.getElementById('color-intensity-slider');
      const intensityValue = document.getElementById('intensity-value');
      const finalColorInput = document.getElementById('final-color');
      
      let baseColor = null;

      // 슬라이더 스타일 업데이트 함수
      function updateSliderAppearance() {
        if (!baseColor) return;
        
        // 슬라이더 배경을 선택된 컬러의 그라데이션으로 설정
        // 왼쪽(1%): 매우 투명한 색상, 오른쪽(100%): 완전한 원본 색상
        const [r, g, b] = hexToRgb(baseColor);
        const lightColor = `rgba(${r}, ${g}, ${b}, 0.1)`; // 10% 투명도
        const fullColor = `rgba(${r}, ${g}, ${b}, 1.0)`;   // 완전 불투명
        
        const gradient = `linear-gradient(to right, ${lightColor}, ${fullColor})`;
        document.documentElement.style.setProperty('--slider-bg-gradient', gradient);
        
        // 현재 슬라이더 위치에 따른 thumb 색상 계산
        const intensityPercent = parseInt(intensitySlider.value);
        const thumbOpacity = intensityPercent / 100;
        const thumbColor = `rgba(${r}, ${g}, ${b}, ${thumbOpacity})`;
        
        document.documentElement.style.setProperty('--slider-thumb-color', thumbColor);
      }

      // 강도 조절 함수 (투명도 기반)
      function updateColorIntensity() {
        if (!baseColor) return;
        
        const intensityPercent = parseInt(intensitySlider.value); // 1~100
        const adjustedColor = adjustColorIntensity(baseColor, intensityPercent);
        
        selectedColorPreview.style.backgroundColor = adjustedColor;
        intensityValue.textContent = intensityPercent + '%';
        
        // 슬라이더 외형 업데이트
        updateSliderAppearance();
        
        // 폼 제출용으로는 원본 HEX 색상 유지 (투명도 정보는 별도 처리)
        if (intensityPercent === 100) {
          finalColorInput.value = baseColor;
        } else {
          finalColorInput.value = adjustedColor;
        }
      }

      // 슬라이더 이벤트
      intensitySlider.addEventListener('input', updateColorIntensity);

      // 모달 열기
      modalBtn.addEventListener('click', () => {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden'; // 배경 스크롤 방지
      });

      // 모달 닫기 함수
      function closeModal() {
        modal.classList.add('hidden');
        document.body.style.overflow = ''; // 배경 스크롤 복원
      }

      // 닫기 버튼 클릭
      modalClose.addEventListener('click', closeModal);

      // 모달 배경 클릭시 닫기
      modal.addEventListener('click', (event) => {
        if (event.target === modal) {
          closeModal();
        }
      });

      // ESC 키로 모달 닫기
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && !modal.classList.contains('hidden')) {
          closeModal();
        }
      });

      // 감정 옵션 클릭 이벤트
      emotionOptions.forEach(option => {
        option.addEventListener('click', () => {
          // 기존 선택 해제
          emotionOptions.forEach(o => o.classList.remove('selected'));
          
          // 새로운 선택
          option.classList.add('selected');
          selectedEmotion = option.dataset.emotion;
          baseColor = option.dataset.color;
          
          selectedEmotionText.textContent = option.textContent;
          selectedEmotionText.classList.remove('text-gray-500');
          selectedEmotionText.classList.add('text-gray-800');
          
          selectedEmotionName.textContent = option.textContent;
          
          // 모달 닫기
          closeModal();
          
          // 컬러 강도 조절 UI 표시
          colorIntensitySection.style.display = 'flex';
          
          // 슬라이더를 기본값(100%)으로 리셋
          intensitySlider.value = '100';
          
          // 초기 컬러 설정 및 슬라이더 외형 업데이트
          updateColorIntensity();
        });
      });
    }

    /*******************
     * FORM SUBMISSION
     *******************/
    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      const textInput = document.getElementById('feeling-text');
      const finalColorInput = document.getElementById('final-color');
      const submitButton = document.getElementById('submit-button');

      const text = textInput.value.trim();
      const color = finalColorInput.value;

      if (!text || !selectedEmotion || !color) {
        status.textContent = '감정, 텍스트, 컬러를 모두 선택해주세요.';
        return;
      }

      submitButton.disabled = true;

      try {
        // Calculate position (닷 기준으로 계산됨)
        const { xPos: fixedX, yPos: fixedY, dotOffsetX, dotOffsetY } = calculateNextLandingPosition(currentSubmissions);
        const fixedRot = Math.random() * 30 - 15;

        const submissionData = {
          id: uuid(),
          text,
          color,
          xPos: fixedX,
          yPos: fixedY,
          rotation: fixedRot,
          dotOffsetX,
          dotOffsetY,
          timestamp: Date.now(),
          userId: userId,
        };

        // Save to Google Sheets
        await saveToGoogleSheets(submissionData);

        // 즉시 로컬에 렌더링 (더 빠른 반응성을 위해)
        currentSubmissions.push(submissionData);
        renderIncremental([submissionData]);
        lastUpdateTime = submissionData.timestamp;

        textInput.value = '';
        
        // 감정 선택 상태 초기화
        document.querySelectorAll('.emotion-option').forEach(option => option.classList.remove('selected'));
        document.getElementById('color-intensity-section').style.display = 'none';
        document.getElementById('selected-color-preview').style.backgroundColor = '#f3f4f6';
        document.getElementById('selected-emotion-text').textContent = 'Choose an emotion...';
        document.getElementById('selected-emotion-text').classList.remove('text-gray-800');
        document.getElementById('selected-emotion-text').classList.add('text-gray-500');
        document.getElementById('selected-emotion-name').textContent = '';
        document.getElementById('color-intensity-slider').value = '100';
        document.getElementById('intensity-value').textContent = '100%';
        document.getElementById('emotion-modal').classList.add('hidden');
        document.body.style.overflow = ''; // 배경 스크롤 복원
        selectedEmotion = null;
        status.textContent = '';

      } catch (error) {
        status.textContent = '전송 중 오류가 발생했습니다.';
      } finally {
        submitButton.disabled = false;
      }
    });

    /*******************
     * INITIALIZATION
     *******************/
    function initialize() {
      ensureInitialBackground();
      updateConnectionStatus();
      
      // 감정 선택 기능 초기화
      initializeEmotionSelection();
      
      // 폴링 시작
      startPolling();
      
      // 로딩 오버레이 제거 (1초 후)
      setTimeout(() => {
        loadingOverlay.style.opacity = '0';
        loadingOverlay.style.visibility = 'hidden';
      }, 1000);
    }

    // 페이지 종료시 폴링 정리
    window.addEventListener('beforeunload', () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    });

    // Start the app
    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
